<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8"/>
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
    <meta http-equiv="Pragma" content="no-cache"/>
    <meta http-equiv="Expires" content="0"/>
    <link rel="shortcut icon" href="/favicon.ico"/>

    <style>
        @import url('lib/element-ui/theme-chalk/index.css');

        body {
            width: 98%;
            margin: 10px auto;
        }

        h1 {
            color: #333;
        }

        .log {
            color: #999;
            font-size: 12px;
        }

        p {
            color: #999;
            font-size: 12px;
        }

        [contenteditable="true"]:empty:before {
            content: attr(placeholder);
            display: block;
            color: #ccc;
        }

        .float-right {
            float: right;
        }

        .fixed-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            text-align: center;
        }

        .link {
            margin-right: 30px;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .socket-status {
            width: 20px;
            height: 20px;
            border-radius: 90px;
        }

        .socket-status-container {
            z-index: 100;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
        }

        .el-dropdown {
            vertical-align: top;
        }

        .el-dropdown + .el-dropdown {
            margin-left: 15px;
        }

        .el-icon-arrow-down {
            font-size: 12px;
        }
    </style>
</head>

<body>
<div id="app" v-cloak>
    <div class="socket-status-container">
        <el-tooltip effect="dark" :content="connected?'Websocket connected':'Websocket disconnected'"
                    placement="left">
            <div class="socket-status" :style="{'background': connected ? '#13ce66' : '#dd6161'}"></div>
        </el-tooltip>
    </div>


    <div style="min-height: 72vh;">
        <el-row>
            <el-col :span="5">
                <h1>R&D Message Test</h1>
            </el-col>
            <el-col :span="3">
                <p style="line-height: 40px">ISO8583 CUPS</p>
            </el-col>
        </el-row>

        <el-row style="margin-top:10px;margin-bottom: 20px">
            <el-col :span="16">
                <el-table ref="multipleTable"
                          :data="fields.filter(data =>  !hide || request[data.no] || response[data.no])"
                          tooltip-effect="dark" border stripe style="width: 100%"
                          @selection-change="handleSelectionChange">
                    <el-table-column type="selection" width="40">
                    </el-table-column>
                    <el-table-column label="Field" width="100">
                        <template slot-scope="scope">
                            <h2>{{ scope.row.no }}</h2>
                        </template>
                    </el-table-column>
                    <el-table-column prop="desc" label="Desc" show-overflow-tooltip>
                        <template slot-scope="scope">
                            <h2>{{ scope.row.desc }}</h2>
                        </template>
                    </el-table-column>
                    <el-table-column v-if="format" label="Format" show-overflow-tooltip width="200">
                        <template slot-scope="scope">
                            <h2>
                                {{ scope.row.type + (scope.row.fixed ? "" : "..") + scope.row.length +
                            (scope.row.format ? "(" + scope.row.format + ")" : "")
                                }}</h2>
                        </template>
                    </el-table-column>
                    <el-table-column label="Request Value" :render-header="renderRequestHeader">
                        <template slot-scope="scope">
                            <el-input width="350" size="large" v-model="request[scope.row.no]"></el-input>
                        </template>
                    </el-table-column>
                    <el-table-column label="Response Value" :render-header="renderResponseHeader">
                        <template slot-scope="scope">
                            <el-input width="350" size="large" readonly v-model="response[scope.row.no]"></el-input>
                        </template>
                    </el-table-column>
                </el-table>
            </el-col>
            <el-col :span="8">
                <el-row style="margin-bottom: 15px" type="flex" justify="space-between">
                    <el-col :span="14"> Templates:
                        <el-select v-model="select" style="width: 60%;"
                                   @change="key=>request=key?JSON.parse(JSON.stringify(optionsMap[key])):{}"
                                   placeholder="Select a template">
                            <el-option v-for="item in options" :key="item.label" :label="item.label"
                                       :value="item.label">
                            </el-option>
                        </el-select>
                    </el-col>
                    <el-col :span="8" style="text-align: right">
                        <el-dropdown :loading="loading" style="width: 100%;" split-button type="primary"
                                     @click="submitForm">
                            <span>Send</span>
                            <el-dropdown-menu slot="dropdown">
                                <el-dropdown-item>
                                    <el-button type="text" size="small" icon="el-icon-delete"
                                               style="width: 100%;"
                                               title="Clear transactions table."
                                               @click="clearTrans">Clear transactions
                                    </el-button>
                                </el-dropdown-item>
                                <el-dropdown-item>
                                    <el-button type="text" size="small" icon="el-icon-download"
                                               style="width: 100%;"
                                               title="Save request and response as json file."
                                               @click="saveFile">Save fields as json
                                    </el-button>
                                </el-dropdown-item>
                                <el-dropdown-item>
                                    <el-upload class="upload-demo" ref="upload" accept=".json" action=''
                                               :on-change="loadFile" :file-list="fileList"
                                               :show-file-list="false"
                                               :auto-upload="false">
                                        <el-button icon="el-icon-upload2" style="width: 100%;" slot="trigger"
                                                   title="Load request and response from a json file."
                                                   size="small" type="text">
                                            Load from json
                                        </el-button>
                                    </el-upload>
                                </el-dropdown-item>
                            </el-dropdown-menu>
                        </el-dropdown>
                    </el-col>
                </el-row>
                <el-row style="margin-bottom: 15px" type="flex" justify="space-between">
                    <el-col>
                        <div style="width: 150px;"><span title="Hide the empty field rows.">HideEmpty</span>
                            :
                            <el-switch v-model="hide">
                            </el-switch>
                        </div>
                    </el-col>
                    <el-col>
                        <div style="width: 120px;"><span title="Return a mock response immediately.">Debug</span>:
                            <el-switch v-model="debug">
                            </el-switch>
                        </div>

                    </el-col>
                    <el-col>
                        <div style="width: 120px;"><span title="Show format column.">Format</span>:
                            <el-switch v-model="format">
                            </el-switch>
                        </div>
                    </el-col>
                    <el-col>
                        <div style="width: 120px;"><span
                                title="Submit the message using WebSocket(async) or Http(sync).">Socket</span> :
                            <el-switch v-model="useSocket">
                            </el-switch>
                        </div>
                    </el-col>
                </el-row>
                <el-row style="margin-bottom: 15px">
                    Transactions:
                    <br/>
                    <el-table ref="singleTable" :data="transactions" max-height="250" border stripe
                              style="width: 100%" highlight-current-row @current-change="handleCurrentChange">
                        <el-table-column type="expand" width="40">
                            <template slot-scope="props">
                                <el-form label-position="left" inline class="demo-table-expand">
                                    <el-form-item label="MessageId">
                                        <span>{{ props.row.messageId }}</span>
                                    </el-form-item>
                                    <el-form-item label="Status">
                                        <span>{{ props.row.status }}</span>
                                    </el-form-item>
                                </el-form>
                            </template>
                        </el-table-column>
                        <el-table-column label="MessageId" show-overflow-tooltip>
                            <template slot-scope="scope">{{ scope.row.messageId }}</template>
                        </el-table-column>
                        <el-table-column label="Status" show-overflow-tooltip width="130">
                            <template slot-scope="scope">
                                <i
                                        :class="scope.row.status === 'Pending' ? 'el-icon-loading' : (scope.row.status === 'Done' ?'el-icon-success':'el-icon-error')"></i>
                                <el-tag
                                        :type="scope.row.status === 'Pending' ? 'warning' : (scope.row.status === 'Done' ?'success':'danger')"
                                        disable-transitions>{{scope.row.status}}
                                </el-tag>
                            </template>
                        </el-table-column>
                    </el-table>
                </el-row>
                <el-row style="margin-bottom: 2px">
                    Console:
                    <br/>
                    <div style="border: 1px solid gray;width: 100%;height: 600px;text-align: left;overflow-x: auto !important;overflow-y: auto !important"
                         ref="chatScroll">
                        <div v-for="(v,k) in info" style="text-align: left">
                            <div style="text-align: left">
                                <span class="log">[{{v.time}}][{{v.type}}][seq:{{k}}]</span>
                            </div>
                            <pre v-if="v.type==='send'">{{JSON.stringify(v.message, null, 2)}}</pre>
                            <div v-else>
                                <pre> <span class="log">request:</span><br/>{{JSON.stringify(v.message.request, null, 2)}}</pre>
                                <pre> <span class="log">requestHex:</span><br/>{{ v.message.requestHex }}</pre>
                                <pre> <span
                                        class="log">request.info:</span><br/>{{v.message.requestInfo && v.message.requestInfo.trim()}}</pre>
                                <pre> <span
                                        class="log">response:</span><br/>{{JSON.stringify(v.message.response, null, 2)}}</pre>
                                <pre> <span class="log">responseHex:</span><br/>{{ v.message.responseHex }}</pre>
                                <pre> <span
                                        class="log">response.info:</span><br/>{{v.message.responseInfo && v.message.responseInfo.trim()}}</pre>
                            </div>
                        </div>
                    </div>
                </el-row>
            </el-col>
        </el-row>
    </div>
</div>
</body>
<script src="lib/vue/vue.js"></script>
<script src="lib/element-ui/index.js"></script>
<script src="lib/axios.min.js"></script>
<script src="lib/websocket-builder.js"></script>
<script>
    function groupBy(list, fn) {
        const groups = {}
        list.forEach(function (o) {
            const group = fn(o)
            groups[group] = groups[group] || []
            groups[group].push(o)
        })
        return groups
    }

    new Vue({
        methods: {
            loadCache() {
                const cachedTransactions = sessionStorage.getItem("TRANS_CACHE")
                if (cachedTransactions) {
                    this.transactions = JSON.parse(cachedTransactions)
                }
                const cachedTransactionsMap = sessionStorage.getItem("TRANS_MAP_CACHE")
                if (cachedTransactionsMap) {
                    this.transactionsMap = JSON.parse(cachedTransactionsMap)
                }
            },
            updateCache() {
                if (this.transactions) {
                    sessionStorage.setItem("TRANS_CACHE", JSON.stringify(this.transactions))
                    sessionStorage.setItem("TRANS_MAP_CACHE", JSON.stringify(this.transactionsMap))
                }
            }
            ,
            clearTrans() {
                this.transactions = []
                this.transactionsMap = {}
                this.updateCache()
            },
            saveFile() {
                const _self = this
                const data = {
                    request: this.request,
                    response: this.response,
                }
                const uri = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(data, null, 2))
                let link = document.createElement('a')
                link.href = uri
                link.download = `template_${_self.formatDate(new Date())}.json`
                document.body.appendChild(link)
                link.click()
            },
            loadFile(file) {
                const _self = this
                _self.fileList = []
                if (file.name.slice(-5) != '.json') {
                    this.$message("only support json file.")
                } else {
                    let fileReader = new FileReader()
                    fileReader.onload = async (e) => {
                        try {
                            let data = e.target.result + ""
                            console.log(data)
                            if (this.isJSON(data)) {
                                const loaded = JSON.parse(data)
                                if (loaded.request) {
                                    _self.request = loaded.request
                                }
                                if (loaded.response) {
                                    _self.response = loaded.response
                                }
                                this.$message('load success.')
                            } else {
                                this.$message('not a json file.')
                            }
                            _self.fileList = []
                        } catch (err) {
                            console.log(`load JSON document from file error: ${err.message}`)
                            this.$message('load error.')
                            _self.fileList = []
                        }
                    }
                    fileReader.readAsText(file.raw)
                }
                return false;
            },
            isJSON(str) {
                if (typeof str == 'string') {
                    try {
                        var obj = JSON.parse(str);
                        if (typeof obj == 'object' && obj) {
                            return true;
                        } else {
                            return false;
                        }
                    } catch (e) {
                        console.log('error：' + str + '!!!' + e);
                        return false;
                    }
                }
                console.log('It is not a string!')
            },
            renderRequestHeader(h, {column, $index}, type) {
                let that = this;
                return h(
                    'div', [
                        h('span', column.label),
                        h('el-button', {
                            props: {
                                type: 'text',
                                size: 'small',
                            },
                            style: 'margin-left: 5px;',
                            on: {
                                click: function () {
                                    that.request = {};
                                    that.response = {};
                                    that.select = null;
                                }
                            }
                        }, 'Clear')
                    ],
                )
            }
            ,
            renderResponseHeader(h, {column, $index}, type) {
                let that = this;
                return h(
                    'div', [
                        h('span', column.label),
                        h('el-button', {
                            props: {
                                type: 'text',
                                size: 'small',
                            },
                            style: 'margin-left: 5px;',
                            on: {
                                click: function () {
                                    that.response = {};
                                }
                            }
                        }, 'Clear')
                    ],
                )
            }
            ,
            generateSocketId() {
                const cachedSocketId = sessionStorage.getItem("SOCKET_ID")
                if (cachedSocketId) {
                    return cachedSocketId
                } else {
                    const socketId = this.generateUuid();
                    sessionStorage.setItem("SOCKET_ID", socketId)
                    return socketId;
                }
            }
            ,
            generateUuid() {
                const s = [];
                const hexDigits = "0123456789abcdef";
                for (let i = 0; i < 36; i++) {
                    s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
                }
                s[14] = "4";   // bits 12-15 of the time_hi_and_version field to 0010
                s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);   // bits 6-7 of the clock_seq_hi_and_reserved to 01
                s[8] = s[13] = s[18] = s[23] = "-";
                const uuid = s.join("");
                return uuid;
            }
            ,
            createWebSocket: function () {
                const that = this
                if (window.socket) {
                    window.socket.close()
                }
                window.socket = WebSockets.newBuilder()
                    .setUrl(`ws://${location.host}/request/${that.socketId}`)
                    .onMessage(this.handleEvent)
                    .onOpen(() => {
                        console.log('Opened ' + that.socketId)
                        window.socket.send({code: 10000, message: 'start'})
                        that.$message({
                            type: 'success',
                            message: "WebSocket connected with socketId " + that.socketId
                        })
                        that.connected = true
                    })
                    .onClose(
                        () => {
                            that.connected = false
                        }
                    )
                    .build()
                window.socket.connect()
                this.socket = window.socket
            }
            ,
            toggleSelection(rows) {
                if (rows) {
                    rows.forEach(row => {
                        this.$refs.multipleTable.toggleRowSelection(row);
                    });
                } else {
                    this.$refs.multipleTable.clearSelection();
                }
            }
            ,
            chatScrollTop() {
                setTimeout(() => {
                    //滚动条长度
                    const currentDistance = this.$refs.chatScroll.scrollHeight - this.$refs.chatScroll.clientHeight;
                    //当前滚动条距离顶部的距离
                    let currentScroll_y = this.$refs.chatScroll.scrollTop;
                    if (currentDistance > 0 && currentDistance - currentScroll_y > 10) {
                        currentScroll_y = Math.ceil((currentDistance - currentScroll_y) / 10) + currentScroll_y;
                        currentScroll_y = currentScroll_y > currentDistance ? currentDistance : currentScroll_y;
                        this.$refs.chatScroll.scrollTop = currentScroll_y;
                        this.chatScrollTop()
                    }
                }, 13);
            }
            ,
            handleSelectionChange(val) {
                this.multipleSelection = val;
            }
            ,
            handleCurrentChange(row) {
                console.log('handleCurrentChange', row)
                console.log('row.message', row.message)
                console.log('row.response', row.response)
                this.request = row.message ? JSON.parse(JSON.stringify(row.message)) : {}
                this.response = row.response ? JSON.parse(JSON.stringify(row.response)) : {}
            },
            leftPad(str, length, use) {
                let pad = use || '0';
                const cnt = length - str.length;
                for (let i = 0; i < cnt; i++) {
                    str = pad + str;
                }
                return str
            },
            formatDate: function (date) {
                const separator1 = "-";
                const separator2 = ":";
                let month = date.getMonth() + 1;
                let strDate = date.getDate();
                if (month >= 1 && month <= 9) {
                    month = "0" + month;
                }
                if (strDate >= 0 && strDate <= 9) {
                    strDate = "0" + strDate;
                }
                return date.getFullYear() + separator1 + month + separator1 + strDate + " " + this.leftPad(date.getHours(), 2, '0') + separator2 + this.leftPad(date.getMinutes(), 2, '0') + separator2 + this.leftPad(date.getSeconds(), 2, '0');
            }
            ,
            validateRequest() {
                if (!this.request[0]) {
                    this.$message({
                        type: 'error',
                        message: "message can not be empty!"
                    })
                    return false
                }
                return true
            }
            ,
            submitForm() {
                const that = this;
                if (!this.validateRequest()) {
                    return
                }
                // that.loading = true
                that.chatScrollTop()
                that.response = {}
                if (this.useSocket) {
                    that.sendRequest()
                } else {
                    that.postRequest()
                }
            }
            ,
            countDown(messageId) {
                const that = this
                setTimeout(() => {
                    if (that.transactionsMap[messageId] && that.transactionsMap[messageId].status === 'Pending') {
                        //TODO 冲正
                        that.transactionsMap[messageId].status = "TimedOut"
                        that.updateCache()
                        console.log(`${messageId} Timed out , reversing.`)
                        that.$message({
                            type: 'error',
                            message: `${messageId} Timed out , reversing.`
                        })
                    }
                }, 15 * 1000)
            }
            ,
            handleEvent(evt) {
                const response = JSON.parse(evt.data)
                console.log("received:", response)
                if (response.code == 10002) {
                    console.log("message :", response)
                    if (this.transactionsMap[response.messageId] && this.transactionsMap[response.messageId].status == "Pending") {
                        this.transactionsMap[response.messageId].status = "Done"
                        this.response = response.data.response
                        this.transactionsMap[response.messageId].response = response.data.response
                        this.updateCache()
                    } else {
                        this.$message({
                            type: 'error',
                            message: `received a timed out message: ${response.messageId},discard!`
                        })
                    }
                    this.info.push({
                        type: 'recv',
                        time: this.formatDate(new Date()),
                        message: response.data
                    })
                    this.chatScrollTop()
                } else if (response.code == 10003) {
                    this.transactionsMap[response.messageId].status = "Failed"
                    this.updateCache()
                    this.$message({
                        type: 'error',
                        message: `message handle error,reason: ${response.reason}!`
                    })
                } else {
                    console.log('received an unsupported message', response)
                }
            }
            ,
            sendRequest() {
                const that = this
                const messageId = this.generateUuid()
                const message = {
                    code: 10001,
                    type: 'send',
                    status: "Pending",
                    debug: this.debug,
                    time: this.formatDate(new Date()),
                    messageId: messageId,
                    message: JSON.parse(JSON.stringify(this.request))
                }
                const str = JSON.stringify(message)
                if (window.socket && window.socket.isOpen()) {
                    window.socket.send(message)
                    that.transactionsMap[messageId] = message
                    that.transactions.unshift(message)
                    that.updateCache()
                    that.info.push(JSON.parse(str))
                    that.countDown(messageId)
                } else {
                    that.$message({
                        type: 'error',
                        message: "WebSocket lose connection,send failed!"
                    })
                }
            }
            ,
            postRequest() {
                const that = this
                that.loading = true
                that.info.push({
                    type: 'send',
                    time: that.formatDate(new Date()),
                    message: JSON.parse(JSON.stringify(this.request))
                })
                axios.post("/message/json", this.request)
                    .then(function (response) {
                        that.loading = false
                        // response not implement yet
                        that.info.push({
                            type: 'recv',
                            time: that.formatDate(new Date()),
                            message: response.data
                        })
                        that.chatScrollTop()
                        // TODO For debug ,need replace response
                        that.response = response.data.request
                    })
                    .catch(function (error) {
                        that.loading = false
                        console.log(error)
                        that.$message({
                            type: 'error',
                            message: error.message
                        })
                    })
            }
            ,
            resetForm(formName) {
                this.$refs[formName].resetFields();
            }
            ,
            getData: function () {
                let that = this
                axios.get("/message/fields").then(response => {
                    that.fields = []
                    for (const k in response.data) {
                        that.fields.push(response.data[k])
                    }
                })
                axios.get("/message/templates").then(response => {
                    that.options = []
                    that.optionsMap = {}
                    for (const k in response.data) {
                        const v = {}
                        for (const j in response.data[k]) {
                            v[j] = response.data[k][j].value
                        }
                        that.optionsMap[k] = v
                        that.options.push(
                            {
                                label: k,
                                value: v
                            }
                        )
                    }
                })
            }
            ,
        },
        el: '#app',
        data() {
            const validateName = async (rule, value, callback) => {
                let that = this
                const res = await axios.get('/record/has?t=' + value);
                if (res.data.data !== 0) {
                    callback(new Error(''));
                } else {
                    callback();
                }
            };
            return {
                response: {},
                request: {},
                fileList: [],
                fields: [],
                info: [],
                connected: false,
                debug: false,
                hide: false,
                useSocket: true,
                format: false,
                loading: false,
                options: [],
                optionsMap: {},
                transactions: [],
                transactionsMap: {},
                socketId: null,
                socket: null,
                select: null,
                selectMessage: null,
                multipleSelection: [],
                rules: {
                    name: [
                        {required: true, message: '', trigger: 'blur'},
                        {validator: validateName, trigger: 'blur'}
                    ],
                    lane: [
                        {required: true, message: '', trigger: 'blur'}
                    ],
                }
            }
        }
        ,
        mounted() {
            this.getData()
            this.loadCache()
            this.socketId = this.generateSocketId();
            this.createWebSocket()
        }
    })
</script>

</html>